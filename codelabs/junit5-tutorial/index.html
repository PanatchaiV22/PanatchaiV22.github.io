
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>JUnit5 Tutorial</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="junit5-tutorial"
                  title="JUnit5 Tutorial"
                  environment="web"
                  feedback-link="https://forms.gle/vdiCfQoiLnuDLb7m9">
    
      <google-codelab-step label="Introduction" duration="5">
        <p><strong>Last Updated:</strong> 2022-11-10</p>
<p>This codelab is focused on writing unit test with JUnit5 and how to refactor the code in different scenarios so that they can be unit testable.</p>
<h2 class="checklist" is-upgraded><strong>What you&#39;ll learn</strong></h2>
<ul class="checklist">
<li>How to create and write unit test with JUnit5.</li>
<li>How to write assertions.</li>
<li>How to use mocks.</li>
</ul>
<h2 is-upgraded><strong>What you&#39;ll need</strong></h2>
<ul>
<li>Android Studio Chipmunk | 2021.2.1 Patch 2 or newer.</li>
<li>Git ​​| 2.37.0 or newer.</li>
</ul>
<h2 is-upgraded><strong>Setup Project</strong></h2>
<h3 is-upgraded><strong>Fork Repository</strong></h3>
<p><a href="https://github.com/PanatchaiV22/solid-principles" target="_blank">https://github.com/PanatchaiV22/solid-principles</a></p>
<h3 is-upgraded><strong>Clone Repository</strong></h3>
<pre>git clone git@github.com:USER_NAME/solid-principles.git</pre>


      </google-codelab-step>
    
      <google-codelab-step label="JUnit5 Lifecycle" duration="5">
        <h2 is-upgraded>Switching Branch</h2>
<pre>git switch feature/original-code</pre>
<h2 is-upgraded>Open Test</h2>
<p>Open the test file <code>JUnit5LifeCycle.kt</code> by using short-key <strong>Command</strong> + <strong>Shift</strong> + <strong>O </strong>then type <code>JUnit5LifeCycle.kt</code></p>
<h2 is-upgraded><strong>Run Test</strong></h2>
<h3 is-upgraded><strong>Using Short Key</strong><br></h3>
<p>To run the test using short-key <strong>Control</strong> + <strong>Shift</strong> + <strong>R</strong>.</p>
<p>Observe the logs inside the test result. Can you make a guess?</p>
<h3 is-upgraded><strong>Using GUI</strong></h3>
<p>Right click on the test and select <em><code>Run ‘JUnit5LifeCycle'</code></em></p>
<p class="image-container"><img style="width: 360.70px" src="img/b8350a417cd03cdc.png"></p>
<h2 is-upgraded><strong>Lifecycle Dissection</strong></h2>
<p>If you click on the <code>JUnit5LifeCycle</code> then you will see the following</p>
<p class="image-container"><img style="width: 624.00px" src="img/8f8a7973a444937d.png"></p>
<p>and if you click on the <code>test()</code> function, you will instead see the following</p>
<p class="image-container"><img style="width: 624.00px" src="img/8035394aef791014.png"></p>
<p>This is because <code>JUnit5LifeCycle</code> represents our test class, a container, which contains each individual test such as our <code>test()</code> method. It should be apparent that both <code>BeforeAll</code> and <code>AfterAll</code> run once per test-class or container before and after all the tests are executed respectively. For that reason both have to be statically defined as <code>@JvmStatic</code> as shown below.</p>
<pre><code>    companion object {
        @JvmStatic
        @BeforeAll
        fun beforeAll() {
            println(&#34;BeforeAll&#34;)
        }

        @JvmStatic
        @AfterAll
        fun afterAll() {
            println(&#34;AfterAll&#34;)
        }
    }</code></pre>
<p>The rest is self explanatory where <code>BeforeEach</code> will be executed before each <code>Test</code> method, then the <code>Test</code> itself is executed, followed by <code>AfterEach</code>. Next we will be doing another experiment on a different lifecycle.</p>
<p>In addition, you can also define <code>@BeforeAll</code> and <code>@AfterAll</code> as non-static function just like any other regular functions by annotating your test class with <code>@TestInstance(TestInstance.Lifecycle.PER_CLASS)</code>. However, this will also change the behavior of the test, which we will be getting into this in detail in a bit.</p>
<h2 is-upgraded><strong>Further Lifecycle Experiment</strong></h2>
<h3 is-upgraded><strong>Rename test() to test1()</strong></h3>
<pre><code>@Test                      @Test
fun test() {               fun test1() {
   println(&#34;Test&#34;)   —&gt;        println(&#34;Test1 ${this.hashCode()}&#34;)
}                          }</code></pre>
<h3 is-upgraded><strong>Add test2() test function</strong></h3>
<pre><code>@Test
fun test2() {
   println(&#34;Test2 ${this.hashCode()}&#34;)
}</code></pre>
<p>Then Run Test</p>
<h3 is-upgraded><strong>The result</strong></h3>
<p>It should be plentifully obvious to point out now that <code>BeforeAll</code> and <code>AfterAll</code> run before and after all the tests respectively.</p>
<p class="image-container"><img style="width: 624.00px" src="img/a01cc69b579b4d7c.png"></p>
<p>While <code>BeforeEach</code> and <code>AfterEach</code> run before and after each individual test respectively as shown below.</p>
<p class="image-container"><img style="width: 624.00px" src="img/afe6ff7066b54f02.png"></p>
<p>This is also important to note that each individual test run on different instance of the test which means they run on a totally separated environment and set of variables. This is because, by default, the lifecycle of the test is per <code>Test</code> method.</p>
<p class="image-container"><img style="width: 624.00px" src="img/140e416c75d9b23e.png"></p>
<h2 is-upgraded><strong>Test Instance Lifecycle</strong></h2>
<p>There are 2 types of lifecycle such as <code>PER_METHOD</code> lifecycle as you have already seen from the above examples. The other is called <code>PER_CLASS</code> lifecycle and the different is the <code>PER_CLASS</code> lifecycle runs on a single instance.</p>
<h3 is-upgraded><strong>Change Test Lifecycle</strong></h3>
<p>Annotate the test to change its lifecycle to <code>PER_CLASS</code>.</p>
<pre><code>@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class JUnit5LifeCycle</code></pre>
<p>Then Run Test</p>
<h3 is-upgraded><strong>The Result</strong></h3>
<p>As you can see, the test instance id is the same throughout the tests.</p>
<p class="image-container"><img style="width: 624.00px" src="img/7566bd8dbc25785.png"></p>
<p>With the <code>Test</code> class annotated as <code>PER_CLASS</code>, you can now declare the <code>BeforeAll</code> and <code>AfterAll</code> as non-static functions as shown.</p>
<pre><code>    @BeforeAll
    fun beforeAll() {
        println(&#34;BeforeAll&#34;)
    }

    @AfterAll
    fun afterAll() {
        println(&#34;AfterAll&#34;)
    }</code></pre>
<p>That&#39;s it! That is all to it for the <strong>JUnit5 Lifecycle</strong>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Quiz" duration="1">
        <p>Can we have multiple <code>@BeforeEach</code> functions?</p>


      </google-codelab-step>
    
      <google-codelab-step label="Unit Test" duration="1">
        <p>Now we can really get into our main objective of this exercise, the Unit Testing, but, before that, let&#39;s have a look at what Unit Test really is.</p>
<p><em>A unit test is a way of testing a unit - the smallest piece of code that can be logically isolated in a system.</em></p>
<p>Let&#39;s also have a look at what is not a Unit Test.</p>
<ul>
<li>It cannot run in parallel with other unit tests.</li>
<li>You have to do special things to your environment (such as editing config files) to run it.</li>
</ul>
<p>So keep those things in mind when writing your tests whether you are writing a Unit Test or something else, Integration Test for example.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Write Your First Unit Test" duration="10">
        <p>In this session, we will be putting what we know so far into practice by creating a brand new unit test on a new class.</p>
<h2 is-upgraded><strong>Open NewUserUseCase class</strong></h2>
<p>Press <code>Command</code> + <code>O</code> then type <code>NewUserUseCase</code>.</p>
<h2 is-upgraded><strong>Create New Test</strong></h2>
<h3 is-upgraded><strong>Using short key</strong></h3>
<p>Pressing <code>Command</code> + <code>N</code> then choose <code>Test..<br></code></p>
<p>Or</p>
<p>Pressing <code>Command</code> + <code>Shift</code> + <code>T</code>, which will ask you to either create a new test or navigate to the existing one.</p>
<p class="image-container"><img style="width: 624.00px" src="img/6560a442a5c66c62.png"></p>
<h3 is-upgraded><strong>Using GUI</strong></h3>
<p>Right click anywhere on the test class and choose <code>Generate</code></p>
<p class="image-container"><img style="width: 624.00px" src="img/e84458465dde68e3.png"></p>
<p>Then choose <code>Test...</code></p>
<p class="image-container"><img style="width: 624.00px" src="img/6560a442a5c66c62.png"></p>
<h2 is-upgraded><strong>Create Test Dialog</strong></h2>
<p>Leave everything to default and click <code>OK</code>.</p>
<p class="image-container"><img style="width: 624.00px" src="img/d9870c1ddb5ff8a0.png"></p>
<p>And click <code>OK</code> again.</p>
<p class="image-container"><img style="width: 624.00px" src="img/27f1277d4948a92a.png"></p>
<h2 is-upgraded><strong>Write Your First Unit Test</strong></h2>
<p>First, we will be writing one test function together then you can finish the rest on your own. To begin with, we will be writing a unit test for the <code>registerUser</code> method to see whether it works as expected or not.</p>
<h3 is-upgraded><strong>Naming Convention</strong></h3>
<p>BBD naming conventions seems to be quite popular amongst developers when it comes to writing unit tests. Here is the format:</p>
<p><code>Given... When... Then...</code></p>
<p>To explicitly explain this in plain English, it goes like this:</p>
<p><code>Given</code> pre-conditions or certain inputs <code>When</code> do something <code>Then</code> expectation</p>
<p>Now let&#39;s look at our <code>registerUser</code>, here is what I would describe our test method as</p>
<ul>
<li><code>Given</code> a user</li>
<li><code>When</code> registering that user</li>
<li><code>Then</code> I would expect <code>registrationService</code> would be called to register the user with the backend.</li>
</ul>
<p>So it would become</p>
<pre><code>    @Test
    fun `GivenUser WhenRegister ThenCallServiceToRegisterUser`() {
        //TODO: check if the registration service is called
    }</code></pre>
<h3 is-upgraded><strong>Declare Unit Under Test</strong></h3>
<pre><code>private lateinit var newUserUseCase: NewUserUseCase</code></pre>
<h3 is-upgraded><strong>Initialize The Unit</strong></h3>
<pre><code>    @BeforeEach
    fun init() {
        newUserUseCase = NewUserUseCase()
    }</code></pre>
<h3 is-upgraded><strong>Update The Test</strong></h3>
<pre><code>    @Test
    fun `GivenUser WhenRegister ThenCallServiceToRegisterUser`() {
        // init mock
        val user = User(&#34;User Name&#34;)

        // execute test
        newUserUseCase.registerUser(user)

        // verify
        // ??????
    }</code></pre>
<p>As it appears that we cannot verify what actually happens once the <code>registerUser(user)</code> is called. Next we will be assessing the situation, finding the root cause, and addressing the problem.</p>
<h3 is-upgraded><strong>Reassess the situation</strong></h3>
<p>Let&#39;s first have a look at the <code>NewUserUseCase</code> implementation</p>
<pre><code>class NewUserUseCase {
    private val registrationService = RegistrationService()
    . . . . .

    fun registerUser(user: User) {
        registrationService.register(user)
    }
    . . . . .
}</code></pre>
<p>As you may now see that the <code>NewUserUseCase</code> is like a black box. The <code>RegistrationService</code> is declared privately and cannot be accessible from the outside world, therefore, cannot be tested as we cannot verify whether it actually does what it is supposed to.</p>
<h3 is-upgraded><strong>A Possible Solution</strong></h3>
<p>Making the <code>registrationService</code> a public field would ease the situation and make the class testable. So our test will now become</p>
<pre><code>    @Test
    fun `GivenUser WhenRegister ThenCallServiceToRegisterUser`() {
        // init mock
        val user = User(&#34;User Name&#34;)
        newUserUseCase.registrationService = mockk()
        justRun { newUserUseCase.registrationService.register(any()) }


        // execute test
        newUserUseCase.registerUser(user)

        // verify
        verify { newUserUseCase.registrationService.register(user) }
    }</code></pre>
<p>Instead of mocking, you can instead use <code>spyk(...)</code> to achieve the same effect. However, please note that a spy is used upon an instance of the object that has already been initialized. This comes into handy when you are dealing with external code or a third-party library that you do not have access to their code. Below is an example of how you can use a spy.<br></p>
<pre><code>newUserUseCase.registrationService = spyk(newUserUseCase.registrationService)</code></pre>
<aside class="special"><p><strong>Note:</strong> By exposing the field as public, however, we would be exposing the representation of the object to its callers and if the representation has to change, so do the callers. In the end, this would create more problems than it solves. In the next section, we will be exploring some other alternatives using best practices to our advantage.</p>
</aside>
<h3 is-upgraded><strong>What is Mock?</strong></h3>
<p>Mocking is primarily used in unit testing. An object under test may have dependencies on other (complex) objects. To isolate the behaviour of the object you want to test, you replace the other objects by mocks that simulate the behaviour of the real objects. This is useful if the real objects are impractical to incorporate into the unit test.</p>
<p>In the above example,</p>
<pre><code>newUserUseCase.registrationService = mockk()</code></pre>
<p>Denotes that the <code>registrationService</code> is mocked. The syntax <code>mockk()</code> is from <a href="https://mockk.io/" target="_blank">MockK</a> mocking framework, which we will be using throughout the course. By default, the mock itself does not do anything unless it is told to. This is why we also need the next line to tell it what to do, which in this case when the <code>registrationService.register(...)</code> is called.<br></p>
<pre><code>justRun { newUserUseCase.registrationService.register(any()) }</code></pre>
<p><code>justRun {...}</code> tells the mock to just execute the method without returning anything (e.g. returning Unit). If your mock returns a value, instead of <code>justRun {...}</code>, you have to use <code>every {...} Returns T</code> syntax.</p>
<p><code>any()</code> tells the mock that the method should accept any parameters we throw at it.</p>
<p>Another way to allow the mock creation without any specific behavior is to passing <code>relaxed = true</code> when declaring the mock. For example,</p>
<pre><code>newUserUseCase.registrationService = mockk(relaxed = true)</code></pre>
<p>This way we can also run the test without having to specify the mock&#39;s behavior e.g.<br></p>
<pre><code>justRun { newUserUseCase.registrationService.register(any()) }</code></pre>
<p>So our test becomes</p>
<pre><code>    @Test
    fun `GivenUser WhenRegister ThenCallServiceToRegisterUser`() {
        // init mock
        val user = User(&#34;User Name&#34;)
        newUserUseCase.registrationService = mockk(relaxed = true)


        // execute test
        newUserUseCase.registerUser(user)

        // verify
        verify { newUserUseCase.registrationService.register(user) }
    }</code></pre>
<p>In addition,</p>
<pre><code>verify { newUserUseCase.registrationService.register(user) }</code></pre>
<p>is the same as</p>
<pre><code>verify { newUserUseCase.registrationService.register(eq(user)) }</code></pre>
<p>Furthermore, if you do not care about what being passed in as the parameter, you can also use <code>any()</code>.</p>
<pre><code>verify { newUserUseCase.registrationService.register(any()) }</code></pre>
<p>Additionally, you can also check how many times the mock is executed by adding</p>
<pre><code>verify(exactly = 1) { newUserUseCase.registrationService.register(any()) }</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="SOLID Principles" duration="10">
        <p>The goal of the SOLID principles is to reduce dependencies so that we can change one area of software without impacting others. Additionally, they&#39;re intended to make designs easier to understand, maintain, and extend.</p>
<h2 is-upgraded><strong>Single Responsibility Principle</strong></h2>
<p>Every class, module, or function in a program should have one responsibility/purpose in a program.</p>
<h2 is-upgraded><strong>Open–Closed Principle</strong></h2>
<p>Objects or entities should be open for extension but closed for modification.</p>
<h2 is-upgraded><strong>Liskov Substitution Principle</strong></h2>
<p>Objects of a superclass should be replaceable with objects of its subclasses without breaking the application.</p>
<h2 is-upgraded><strong>Interface Segregation Principle</strong></h2>
<p>No code should be forced to depend on methods it does not use.</p>
<h2 is-upgraded><strong>Dependency Inversion Principle</strong></h2>
<p>high level modules should not depend on low level modules and both should depend on abstractions.</p>
<h2 is-upgraded><strong>Composition Over Inheritance</strong></h2>
<p>This principle simply states that classes should achieve polymorphic behavior and code reuse by their composition (by containing instances of other classes that implement the desired functionality) rather than inheritance from a base or parent class, which make the composition more loosely coupled than the inheritance. </p>
<h3 is-upgraded><strong>Let&#39;s Define Our Basic Components</strong></h3>
<pre><code>Interface Analytic {
    fun trackEvent(e: Event) { ... }
    fun trackView(v: View) { ... }
}

Class SegmentAnalytic: Analytic {
    override fun trackEvent(e: Event) { ... }
    override fun trackView(v: View) { ... }
}</code></pre>
<p>Now let&#39;s consider the case where we need a little more specialize case of the <code>SegmentAnalytic</code>, for example, adding a transaction id along with other analytic data. We could either implement it using</p>
<h3 is-upgraded><strong>Inheritance Approach</strong></h3>
<pre><code>Class TransactionAnalytic: `SegmentAnalytic` {
    override fun trackEvent(e: Event) {
        addTransactionId(e)
        `super.trackEvent(e)`
    }

    private fun addTransactionId(e: Event) { ... }
    ...
}</code></pre>
<p>Or</p>
<h3 is-upgraded><strong>Composition Approach</strong></h3>
<pre><code>Class TransactionAnalytic(`segment: Analytic`): Analytic {
    override fun trackEvent(e: Event) {
        addTransactionId(e)
        `segment.trackEvent(e)`
    }

    private fun addTransactionId(e: Event) { ... }
    ...
}</code></pre>
<p>The vial differences are highlighted in <code>`Green`</code>. While both implementations can achieve the exact same result, e.g. code reuse, the later approach has the advantage that the child is loosely coupled to its parent, which will make a difference in terms of maintenance and unit testing.</p>
<h2 is-upgraded><strong>Revisit Our NewUserUseCase Example</strong></h2>
<pre><code>class NewUserUseCase {
    var registrationService = RegistrationService()
    private val emailService = EmailService()
    private val userService = UserService()

    fun registerUser(user: User) {
        registrationService.register(user)
    }

    fun sendEmailToUser(user: User) {
        emailService.sendEmailToUser(user)
    }

    fun updateUseDetail(user: User) {
        userService.updateUserDetail(user)
    }
}</code></pre>
<p>To break it down, the <code>NewUserUseCase</code> breaks multiple principles but, for now, what we are interested in particularly is the <strong>Dependency Inversion Principle</strong>. Not only the class publicly exposes its field or property so that we can write test for the class, it also know how to initialize the <code>RegistrationService</code>.</p>
<p>After applying the principle to achieve the same effect, the <code>RegistrationService</code> is passed in as a constructor parameter instead of being declared and initialized privately.</p>
<pre><code>class NewUserUseCase(
    private val registrationService: RegistrationService,
    . . . .
) {

    fun registerUser(user: User) {
        registrationService.register(user)
    }
    . . . .
}</code></pre>
<p>And our test will become<br></p>
<pre><code>internal class NewUserUseCaseTest {

    private lateinit var newUserUseCase: NewUserUseCase

    private val registrationService: RegistrationService = mockk(relaxed = true)
    . . . .

    @BeforeEach
    fun init() {
        newUserUseCase = NewUserUseCase(registrationService, ...)
    }

    @Test
    fun `GivenUser WhenRegister ThenCallServiceToRegisterUser`() {
        // init mock
        val user = User(&#34;User Name&#34;)

        // execute test
        newUserUseCase.registerUser(user)

        // verify
        verify { registrationService.register(user) }
    }
}</code></pre>
<p>If you are interested in seeing the fully refactored code, please check out the <em>refactor-original-code</em> branch.</p>
<pre>git switch /feature/refactor-original-code</pre>


      </google-codelab-step>
    
      <google-codelab-step label="Quiz" duration="1">
        <p>If you are asked to write two classes that represent <code>Squares</code> and <code>Rectangles</code>, which one would be your base class?</p>
<p class="image-container"><img style="width: 624.00px" src="img/52018a150df54ae4.jpeg"></p>


      </google-codelab-step>
    
      <google-codelab-step label="MockK and Assertion" duration="10">
        <h2 is-upgraded><strong>Recapped</strong></h2>
<p>Let&#39;s recap what we have so far.</p>
<pre><code>class NewUserUseCase(
    private val registrationService: RegistrationService,
    . . . .
) {

    fun registerUser(user: User) {
        registrationService.register(user)
    }
    . . . .
}</code></pre>
<p>And the test</p>
<pre><code>internal class NewUserUseCaseTest {

    private lateinit var newUserUseCase: NewUserUseCase

    private val registrationService: RegistrationService = mockk(relaxed = true)
    . . . .

    @BeforeEach
    fun init() {
        newUserUseCase = NewUserUseCase(registrationService, ...)
    }

    @Test
    fun `GivenUser WhenRegister ThenCallServiceToRegisterUser`() {
        // init mock
        val user = User(&#34;User Name&#34;)

        // execute test
        newUserUseCase.registerUser(user)

        // verify
        verify { registrationService.register(user) }
    }
}</code></pre>
<h2 is-upgraded><strong>MockK</strong></h2>
<p>MockK is a mocking framework which allows us to isolate and simulate objects in unit testing. It also allows us to check whether or not the mock works exactly as it should be. Taking an example from the above code, <code>verify { ... }</code> checks for 2 things in order to pass the test. </p>
<p>Firstly it checks whether the mock, <code>registrationService.register(...)</code>, is called or not. Secondly the parameter being passed in is exactly the same as the one the mock receives.</p>
<p>Let&#39;s make some changes to the <code>NewUserUseCase</code> so that it applies some changes to the data just like it would in the real world, for instance, appending a timestamp to the user name.</p>
<pre><code>class NewUserUseCase(
    private val registrationService: RegistrationService,
    . . . .
) {

    fun registerUser(user: User) {
        registrationService.register(
            user.copy(name = &#34;${user.name}-${Date().time}&#34;)
        )
    }
}</code></pre>
<p>If you run the test again, it should fail.</p>
<p class="image-container"><img style="width: 624.00px" src="img/e0ccc041dddce36f.png"></p>
<p>The interesting thing is this particular statement.</p>
<pre>arguments are not matching:
[0]: argument: User(name=User Name-1668274907163), matcher: eq(User(name=User Name))</pre>
<p>Now we will have to fix our test too but how? Please take a moment to think what would you do in this situation.</p>
<p>One common mistake that could happen here is that one would <code>copy & paste</code> the code from what we have just changed into our test like this</p>
<pre><code>verify {
            registrationService.register(
                user.copy(name = &#34;${user.name}-${Date().time}&#34;)
            )
       }</code></pre>
<p>If you try to run the test, it would fail miserably. Let&#39;s have a look at the error message.</p>
<pre>arguments are not matching:
[0]: argument: User(name=User Name-1668275599662), matcher: eq(User(name=User Name-1668275599922))</pre>
<p>As you can clearly see, the timestamps are different! This is because the code is executed first then, slightly after, the test so it is natural that the timestamps are not the same. </p>
<p>I am almost certain that some of you would then think of checking whether or not the timestamp is within a certain range. This is yet another common mistake as there is no guarantee of how long the code would take to execute.</p>
<p>A cleaner way to test this is to somehow be able to capture the exact parameter being passed in and check if a timestamp is appended. Fortunately <a href="https://mockk.io/" target="_blank">MockK</a> has already provided us a way to do just that and I mean capturing the parameter. Now let&#39;s update our test.</p>
<p>First declare a capture slot as shown</p>
<pre><code>val captureSlot = slot&lt;User&gt;()</code></pre>
<p>Then capture the parameter inside the <code>verify { ... }</code> statement as shown</p>
<pre><code>verify {
            registrationService.register(capture(captureSlot))
       }</code></pre>
<p>Congratulations! Now that you have successfully captured the <code>User</code> parameter and it can be accessed by using <code>captureSlot.captured</code> syntax. This will give you the <code>User</code> parameter that the mocked receives.</p>
<p>Next we have to check whether the timestamp is appended to the end of the username or not and, in this case, let&#39;s say that we do not care what the timestamp really is for as long as it is there. However, as mentioned above, there is no way to achieve what we want as this is not what mocking framework is designed to do.</p>
<h2 is-upgraded><strong>Assertion</strong></h2>
<p>Assertion comes to rescue. A simple explanation of the Assertion is as follow<br></p>
<p><em>An assertion is a boolean expression at a specific point in a program which will be true unless there is a bug in the program.</em></p>
<p>Below code show one way of writing assertions to test the code.</p>
<pre><code>        val splits = captureSlot.captured.name.split(&#34;-&#34;)
        Assertions.assertEquals(2, splits.size)
        Assertions.assertEquals(user.name, splits[0])
        Assertions.assertTrue(splits[1].isNotEmpty())</code></pre>
<p>Firstly username is splitted in half exactly where the <code>"-"</code> is and, as a result, this should occupy 2 memory slots inside the list called <code>splits</code>. The first, <code>splits[0]</code>, should contain the username and the second, <code>splits[1]</code>, should be our timestamp.</p>
<p>As you can see that we only check if it is not empty as we do not care what it is for as long as it presents. In any unfortunate events that the timestamp is not appended, the assertions should fail for either the size of the array are not what is expected, e.g. 2, or the timestamp becomes empty.</p>
<p>There are bunches of available APIs, from both MockK and Assertions, we can use to write our unit test. You can check them out by following the links down below. Knowing the features of these tools will help you write a better unit test.</p>
<h3 is-upgraded><strong>MockK</strong></h3>
<ul>
<li><h3 is-upgraded><a href="https://mockk.io/" target="_blank">https://mockk.io/</a></h3>
</li>
</ul>
<h3 is-upgraded><strong>Assertion</strong></h3>
<ul>
<li><a href="https://junit.org/junit5/docs/5.0.1/api/org/junit/jupiter/api/Assertions.html" target="_blank">JUnit5 Assertions</a></li>
<li><a href="https://assertj.github.io/doc/" target="_blank">AssertJ</a></li>
<li><a href="https://kotest.io/" target="_blank">Kotest</a></li>
</ul>
<p>Here is also an interesting comparison between the Assertion libraries.</p>
<p><a href="https://github.com/phellipealexandre/KotlinAssertionLibraryComparison" target="_blank">https://github.com/phellipealexandre/KotlinAssertionLibraryComparison</a></p>


      </google-codelab-step>
    
      <google-codelab-step label="Quiz" duration="1">
        <p>Which one would you prefer?</p>
<pre><code>class NewUserUseCase(
    private val registrationService: RegistrationService,
    . . . .
) {
    . . . .
}</code></pre>
<p>VS</p>
<pre><code>class NewUserUseCase {
    private val registrationService: RegistrationService by inject()
    . . . .
}</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="More Realistic Example" duration="15">
        <p>Before we begin, please fork</p>
<pre>https://github.com/monacohq/monaco-android</pre>
<p>Then clone it</p>
<pre>git clone git@github.com:monacohq/monaco-android.git</pre>
<p>Then switch to the branch <code>feature/basic-unit-test</code></p>
<pre>git switch feature/basic-unit-test</pre>
<h2 is-upgraded>Open <strong><code>PortfolioTrackingViewModel</code></strong></h2>
<p>By pressing <code>Command</code> + <code>O</code>, then type <code>PortfolioTrackingViewModel</code></p>
<h2 is-upgraded><strong>Create Test For The ViewModel</strong></h2>
<p>If you cannot remember how, please revisit <strong>Write Your First Unit Test</strong>.</p>
<h3 is-upgraded><strong>Annotated the test class with MockKExtension</strong></h3>
<pre><code>@ExtendWith(
   MockKExtension::class
)
internal class PortfolioTrackingViewModelTest</code></pre>
<p>If you remember from our previous session, here is how we mock an object.</p>
<pre><code>variable-name: variable-type = mockk([relaxed = true])</code></pre>
<p>By applying the <code>MockKExtension</code>, it allows us to annotate any variables that we want to mock as shown below.</p>
<aside class="special"><p><strong>Tip: </strong>Extension is a way to add more capabilities to the test in the JUnit5. There are many more extensions we can utilize including writing our own Extensions. We will be exploring this in the future tutorial.</p>
</aside>
<h3 is-upgraded><strong>Mock ISettingRepository</strong></h3>
<pre><code>@MockK(relaxed = true)
lateinit var settingRepository: ISettingRepository</code></pre>
<h3 is-upgraded><strong>Mock UrlRepository</strong></h3>
<pre><code>@MockK(relaxed = true)
lateinit var urlRepository: UrlRepository</code></pre>
<h3 is-upgraded><strong>Declare the ViewModel Instance And Initialize It.</strong></h3>
<pre><code>private lateinit var vm: PortfolioTrackingViewModel

@BeforeEach
fun init() {
   vm = PortfolioTrackingViewModel(settingRepository, urlRepository)
}</code></pre>
<p>By passing in 2 mocks into our constructor, we can easily control their behaviors and verify if the code work exactly what it should be.</p>
<h3 is-upgraded><strong>Create Tests for onUiAction</strong></h3>
<p>The <code>SetEnablePieChartIcon</code> is an <code>UiAction</code> which contains 2 possible values, either <code>TRUE</code> or <code>FALSE</code>. So we end up with 2 tests, one where the value is <code>TRUE</code> and other where the value is <code>FALSE</code>.</p>
<pre><code>@Test
fun `GivenTrue onUiAction UpdateViewState`() = runTest {...}
        
@Test
fun `GivenFalse onUiAction UpdateViewState`() = runTest {...}</code></pre>
<h3 is-upgraded><strong>Write the First Test</strong></h3>
<pre><code>@Test
fun `GivenTrue onUiAction UpdateViewState`() = runTest {
   vm.viewStateFlow.test {
       with(awaitItem()) {
           Assertions.assertTrue(enablePieChartIcon)
       }

       vm.onUiAction(PnlTrackingState.Action.SetEnablePieChartIcon(true))

       expectNoEvents()
   }
}</code></pre>
<aside class="special"><p><strong>Tip: </strong>Both <code>awaitItem()</code> and <code>expectNoEvents()</code> are provided by <a href="https://github.com/cashapp/turbine" target="_blank">Turbine</a> to facilitate testing Flow. You can call <code>awaitItem()</code> to suspend and wait for an item to be sent to the Turbine. While <code>expectNoEvents()</code> is for verifying there should be no more events from the current Flow.</p>
</aside>
<h3 is-upgraded><strong>Run the Test</strong></h3>
<p>Press <code>Control</code> + <code>Shift</code> + <code>R</code>.</p>
<h3 is-upgraded><strong>Fix the Test</strong></h3>
<p>Great! You should now get an error as the function is a co-routines and we have not set the main dispatcher yet. So fix the code by adding</p>
<pre><code>    @BeforeEach
    fun init() {
        Dispatchers.setMain(UnconfinedTestDispatcher())
    }</code></pre>
<p>Run the test again and it should now pass.<br></p>
<aside class="special"><p><strong>Tip: UnconfinedTestDispatcher</strong>: Coroutines will start running immediately, without waiting for the coroutine builder to return. It could be a good choice for simple test with coroutines. For more info, please visit our <a href="https://mcoproduct.atlassian.net/wiki/spaces/ANDROID/pages/2300183795/Testing+overview" target="_blank">Confluence</a> page.</p>
</aside>
<p>Please complete the other test for yourself and see you in the next session.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Another Realistic Example" duration="15">
        <p>Let&#39;s pick up another class to write our Unit Test.</p>
<h2 is-upgraded>Test RxJava</h2>
<p>If you cannot remember how, please revisit <strong>Write Your First Unit Test</strong>.</p>
<h3 is-upgraded><strong>Open CaCardShippingAddressConfirmationViewModel</strong></h3>
<p>By pressing Command + O, then type CaCardShippingAddressConfirmationViewModel</p>
<h3 is-upgraded><strong>Annotated Extensions</strong></h3>
<pre><code>@ExtendWith(
   MockKExtension::class,
   InstantExecutorExtension::class,
   TestRxJavaExtension::class
)
internal class CaCardShippingAddressConfirmationViewModelTest</code></pre>
<aside class="special"><p><strong>Tip: </strong><code>InstantExecutorExtension</code> tells the Looper to execute immediately and the <code>TestRxJavaExtension</code> will set Schedulers for RxJava for our tests.</p>
</aside>
<h3 is-upgraded><strong>Mock the TranslationRepository.</strong></h3>
<pre><code>@MockK(relaxed = true)
lateinit var translationRepo: TranslationRepository</code></pre>
<h3 is-upgraded><strong>Declare the ViewModel Instance</strong></h3>
<pre><code>private lateinit var vm: CaCardShippingAddressConfirmationViewModel</code></pre>
<h3 is-upgraded><strong>Create the BeforeEach method.</strong></h3>
<pre><code>@BeforeEach
fun init()</code></pre>
<h3 is-upgraded><strong>Initialize Koin</strong></h3>
<p>Inside the <code>BeforeEach</code> method, create the <code>Koin</code> instance.</p>
<pre><code>@BeforeEach
fun init() {
    startKoin {
        modules(
            module {
                single { translationRepo }
               }
           )
    }
}</code></pre>
<aside class="warning"><p><strong>Note:</strong> You will often encounter this situation in the main app where you have to deal with initializing the DI Graph, e.g. Koin instance in this case. There are many ways to handle this kind of situation but, for now, let&#39;s keep it simple by manually initializing it ourselves. We will be exploring the alternatives later on in the next tutorial.</p>
</aside>
<h3 is-upgraded><strong>Initialise the ViewModel Instance</strong></h3>
<pre><code>vm = CaCardShippingAddressConfirmationViewModel(
   mockk(relaxed = true),
   translationRepo,
   mockk(relaxed = true),
   mockk(relaxed = true),
   mockk(relaxed = true),
   mockk(relaxed = true)
)</code></pre>
<h3 is-upgraded><strong>Create a test for captionObs</strong></h3>
<pre><code>@Test
fun `Given resourceId WhenGetCaptionObs Then return StringValue`() {
   every {
      translationRepo.getStringRx(any(), *anyVararg())
   } returns Maybe.just(&#34;Test&#34;)
   vm.captionObs.test().assertValue(&#34;Test&#34;)
}</code></pre>
<h3 is-upgraded><strong>Run the Test</strong></h3>
<p>Press <code>Control</code> + <code>Shift</code> + <code>R</code>.</p>
<p>Congratulations! That is how you test the RxJava as simple as that. Next we will be seeing how we can test a <code>LiveData</code> as well.</p>
<h2 is-upgraded><strong>Test LiveData</strong></h2>
<p>Often in the main app, you will find yourself a very familiar situation as our first unit test. The class that we are about to test cannot be unit tested, not unless we make some changes.</p>
<h3 is-upgraded><strong>Refactor CaCardShippingAddressConfirmationViewModel</strong></h3>
<p>Change the mAddress declaration visibility to public for testing.</p>
<p>From</p>
<pre><code>private var mAddress = MutableLiveData&lt;CaAddress?&gt;(null)</code></pre>
<p>To</p>
<pre><code>@VisibleForTesting
var mAddress = MutableLiveData&lt;CaAddress?&gt;(null)</code></pre>
<h3 is-upgraded><strong>Create Another Test</strong></h3>
<pre><code>@Test
fun `GivenAddress = &#34;Test&#34; WhenGetTvAppliedAddressText Then return &#34;Test&#34;`()</code></pre>
<h3 is-upgraded><strong>Add Test Body</strong></h3>
<pre><code>        val obs = TestObserver&lt;String&gt;()

        vm.tvAppliedAddressText.observeForever(obs)

        Assertions.assertTrue(obs.values().isNotEmpty())
        Assertions.assertTrue(obs.values().first().isEmpty())

        vm.mAddress.value = CaAddress(address = &#34;Test&#34;)

        Assertions.assertEquals(&#34;Test,\n&#34;, obs.values().last())</code></pre>
<h3 is-upgraded><strong>Run the Test</strong></h3>
<p>Press <code>Control</code> + <code>Shift</code> + <code>R</code>.</p>
<p>Oops! Koin is back to haunt us again. Let&#39;s fix the error by cleaning up the Koin instance from the previous session.</p>
<h3 is-upgraded><strong>Fix Koin</strong></h3>
<p>Fix the bug by adding <code>AfterEach</code> method to stop Koin.</p>
<pre><code>@AfterEach
fun cleanUp() {
   stopKoin()
}</code></pre>
<h3 is-upgraded><strong>Run Test Again</strong></h3>
<p>Press <code>Control</code> + <code>Shift</code> + <code>R</code>.</p>
<p>Congratulations! We have successfully run the tests for both <code>LIveData</code> and <code>RxJava</code>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Take Away" duration="1">
        <p>In this tutorial, you have learned how to create and write unit tests. Furthermore, you have already learned how to handle Coroutines, RxJava, LiveData, and Koin when writing tests. Last but not least, you have also learned how to refactor the code to make it testable, although not necessarily a unit test, using some of the best practices.</p>
<p>Thank you for reading this far and see you again in the next tutorial where we will be digging deep into the feature of the JUnit5 and more advance cases for testing such as how to handle DI graph.</p>
<p>If you like this tutorial and want to see more tutorials like this, please help me making it happens by taking this short survey, <a href="https://forms.gle/vdiCfQoiLnuDLb7m9" target="_blank">https://forms.gle/vdiCfQoiLnuDLb7m9</a>. Thanks and see you next time!</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
